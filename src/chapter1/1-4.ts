/*
  1.4 함수형 자바스크립트를 위한 기초
  함수를 다루는 다양한 방법들을 잘 익히는 것이 중요하다.
  그러려면 함수와 관련된 개념들과 몇가지 기능들에 대해 알아야 한다.
  일급 함수, 클로저, 고차 함수, 콜백 패턴, 부분 적용, arguments 객체 다루기, 함수 객체의 method 등등
*/

/*
  1.4.1. 일급 함수
  자바스크립트에서 함수는 일급 객체이자 일급 함수이다.
    - 변수에 담을 수 있다.
    - 함수나 메서드의 인자로 넘길 수 있다.
    - 함수나 메서드에서 리턴할 수 있다.
    + 아무 때나(런타임에서도) 선언이 가능하다.
    + 익명으로 선언할 수 있다.
    + 익명으로 선언한 함수도 함수나 메서드의 인자로 넘길 수 있다.
*/

/*
  1.4.2. 클로저
  클로저에 대해서 보다 잘 이해하기 위해서는 스코프에 대해 알아야 한다.
  스코프는 변수를 어디에서 어떻게 찾을지를 정한 규칙이다.
  함수는 변수 참조 범위를 결정하는 중요한 기준이다.

  * 클로저는 자신이 생성될 당시의 환경을 기억하는 함수이다.
  * 클로저는 자신이 생성될 때의 스코프레벨에서 알 수 있었던 변수를 기억하는 함수이다.
  
  함수가 의미적으로나 기능적으로나 진짜 클로저가 되기 위한 가장 중요한 조건은 다음과 같다.

  * 클로저로 만들 함수가 myfn이라면, myfn 내부에서 사용하고 있는 변수 중에 myfn 내부에서 선언되지 않은 변수가 있어야 한다.
    그 변수를 a라고 한다면, a라는 이름의 변수가 myfn을 생성하는 스코프에서 선언되었거나 알 수 있어야 한다.

  클로저는 자신이 생성되는 스코프의 실행 컨텍스트에서 만들어졌거나 알 수 있었던 변수 중 언젠가 자신이 실행될 때
  사용할 변수들만 기억하는 함수이다.
  클로저가 기억하는 변수의 값은 언제든 남이나 자신에 의해 변경될 수 있다.
*/

function outer1() {
  var a = 5;
  return function () {
    // 익명 함수는 생성 당시의 스코프 레벨의 변수인 a의 정보를 기억한다.
    console.log(a);
  };
}

/*
  1.4.3. 클로저의 실용 사례
    - 은닉
    - 이전 상황을 나중에 일어날 상황과 이어 나갈 때
      * 이벤트 리스너로 함수를 넘기기 이전에 알 수 있던 상황들을 변수에 담아 클로저로 만들어 기억해 두면,
        이벤트가 발생되어 클로저가 실행되었을 때 기억해 두었던 변수들로 이전 상황들을 이어갈 수 있다.
    - 함수로 함수를 만들거나 부분 적용을 할 때
*/

/*
  1.4.5 고차 함수
    1. 함수를 인자로 받아 대신 실행하는 함수
    2. 함수를 리턴하는 함수
    3. 함수를 인자로 받아서 또 다른 함수를 리턴하는 함수
*/

// code 1-48 함수를 인자로 받아 대신 실행하는 함수
function callWithValue(value, func) {
  return func(10, value);
}

function add(a: number, b: number): number {
  return a + b;
}
function sub(a: number, b: number): number {
  return a - b;
}

// console.log("code 1-48", callWithValue(20, add), callWithValue(5, sub));
/*
  add, sub는 일반 함수이다. callWithValue는 고차 함수다.
*/

// code 1-49 함수를 리턴하는 함수
function constant(value) {
  return function () {
    return value;
  };
}
const always10 = constant(10);
// console.log(always10());
/*
  constant 함수는 value를 받아 내부에서 익명함수를 클로저로 만들어 value를 기억하게 만든 뒤 리턴한다.
*/

// code 1-50 함수를 대신 실행하는 함수를 리턴하는 함수
function callWith(value1: any): Function {
  return function (value2: any, func: Function): Function {
    return func(value1, value2);
  };
}

const callWith10 = callWith(10);
const callWith5 = callWith(5);

// console.log("code 1-50", callWith10(20, add), callWith5(10, sub));
/*
  callWith 함수를 통해 value값을 자유롭게 설정할 수 있다.
  parameter의 타입은 숫자 뿐만 아니라 그 어떤 값도 올 수 있다.
*/
// console.log(
//   "callWith를 활용한 예제",
//   callWith([1, 2, 3, 4, 5, 6])(2, (list, target) =>
//     list.filter((num) => num % target === 0)
//   )
// );

/*
  1.4.6 콜백 함수라 잘못 불리는 보조 함수
  콜백 함수를 받아 자신이 해야 할 일을 모두 마친 뒤 결과를 되돌려 주는 함수도 고차함수다.
  보통은 비동기가 일어나는 상황에서 사용되며, 콜백 함수를 통해 다시 원래 위치로 돌아오기 위해 사용되는 패턴이다.
  콜백 패턴은 클로저 등과 함께 사용할 수 있는 매우 강력한 표현이자 비동기 프로그래밍에 있어 없어서는 안 될 매우 중요한 패턴이다.
  콜백 패턴은 끝이 나면 컨텍스트를 다시 돌려주는 단순한 협업 로직을 가진다.

  컨텍스트를 다시 되돌려 주는 역할을 하는 함수를 콜백함수라 해야 한다.
  인자로 사용되는 모든 함수나 익명 함수가 넘겨지고 있는 모양을 보면 무조건 콜백 함수라 칭하는 경향이 있는데
  이는 잘못된 인지라고 볼 수 있다.
  element.addEventListener('click', function() {})에 전달되는 익명 함수는 콜백이 아니라 '이벤트 리스너'라 칭하는것이 적합하다.
*/
